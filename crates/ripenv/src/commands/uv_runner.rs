//! Shared infrastructure for running uv commands.
//!
//! All ripenv commands that delegate to uv go through this module.
//! The [`UvContext`] handles:
//!
//! 1. Discovering the Pipfile and project root
//! 2. Generating a virtual `pyproject.toml` from the Pipfile
//! 3. Providing uv types (Printer, Cache, etc.) for direct library calls

use std::path::{Path, PathBuf};

use anyhow::{Context, Result};
use uv_cache::Cache;
use uv_client::BaseClientBuilder;
use uv_configuration::Concurrency;
use uv_preview::Preview;
use uv_python::{PythonDownloads, PythonPreference};
use uv_settings::PythonInstallMirrors;

use crate::pipfile::bridge::pipfile_to_pyproject_toml;
use crate::pipfile::discovery::{find_pipfile, project_name_from_dir};
use crate::pipfile::model::Pipfile;
use crate::printer::Printer;

/// Header written to the generated pyproject.toml so users know not to edit it.
const GENERATED_HEADER: &str = "\
# Auto-generated by ripenv from Pipfile. DO NOT EDIT.\n\
# This file is used internally by ripenv to delegate to uv.\n\
# Your source of truth is the Pipfile.\n\n";

/// Shared context for running uv commands.
///
/// Holds the parsed Pipfile, project paths, and printer configuration.
/// All command modules create a `UvContext` via [`UvContext::discover`],
/// then use the helper methods to construct uv types for direct library calls.
pub struct UvContext {
    /// The parsed Pipfile.
    pub pipfile: Pipfile,
    /// Path to the Pipfile.
    pub pipfile_path: PathBuf,
    /// Project root directory (parent of Pipfile).
    pub project_dir: PathBuf,
    /// Path to the generated pyproject.toml.
    pub pyproject_path: PathBuf,
    /// Output printer (ripenv's own printer for ripenv-specific messages).
    pub printer: Printer,
    /// Verbosity level (0 = normal, 1+ = verbose).
    pub verbosity: u8,
    /// Whether output is suppressed.
    pub quiet: bool,
}

impl UvContext {
    /// Discover the Pipfile and set up the context.
    ///
    /// Walks up from the current directory to find the Pipfile, parses it,
    /// generates the virtual pyproject.toml, and writes it to disk.
    pub fn discover(printer: Printer, verbosity: u8, quiet: bool) -> Result<Self> {
        let cwd = std::env::current_dir().context("failed to get current directory")?;
        let pipfile_path = find_pipfile(&cwd)?;
        Self::from_pipfile_path(pipfile_path, printer, verbosity, quiet)
    }

    /// Discover or create a Pipfile, then set up the context.
    ///
    /// Like [`discover`](Self::discover), but if no Pipfile is found, creates a
    /// default one in the current directory (matching `pipenv install` behavior).
    pub fn discover_or_init(printer: Printer, verbosity: u8, quiet: bool) -> Result<Self> {
        let cwd = std::env::current_dir().context("failed to get current directory")?;
        let pipfile_path = if let Ok(path) = find_pipfile(&cwd) {
            path
        } else {
            let path = cwd.join("Pipfile");
            let pipfile = Pipfile::default_new();
            pipfile.write_to(&path)?;
            printer.info(&format!("Created new Pipfile at {}", path.display()));
            path
        };
        Self::from_pipfile_path(pipfile_path, printer, verbosity, quiet)
    }

    /// Build a `UvContext` from an already-located Pipfile path.
    fn from_pipfile_path(
        pipfile_path: PathBuf,
        printer: Printer,
        verbosity: u8,
        quiet: bool,
    ) -> Result<Self> {
        let project_dir = pipfile_path
            .parent()
            .context("Pipfile has no parent directory")?
            .to_path_buf();
        let pyproject_path = project_dir.join("pyproject.toml");

        let pipfile = Pipfile::from_path(&pipfile_path).context("failed to parse Pipfile")?;

        let ctx = Self {
            pipfile,
            pipfile_path,
            project_dir,
            pyproject_path,
            printer,
            verbosity,
            quiet,
        };

        ctx.write_virtual_pyproject()?;

        Ok(ctx)
    }

    /// Write the virtual pyproject.toml to the project directory.
    pub fn write_virtual_pyproject(&self) -> Result<()> {
        let project_name = project_name_from_dir(&self.project_dir);
        let toml = pipfile_to_pyproject_toml(&self.pipfile, &project_name)?;
        let content = format!("{GENERATED_HEADER}{toml}");
        fs_err::write(&self.pyproject_path, content)
            .context("failed to write virtual pyproject.toml")?;
        self.printer.debug(&format!(
            "Wrote virtual pyproject.toml to {}",
            self.pyproject_path.display()
        ));
        Ok(())
    }

    /// Re-read the Pipfile and regenerate the virtual pyproject.toml.
    ///
    /// Call this after modifying the Pipfile (e.g., after `install` or `uninstall`).
    pub fn refresh(&mut self) -> Result<()> {
        self.pipfile =
            Pipfile::from_path(&self.pipfile_path).context("failed to re-parse Pipfile")?;
        self.write_virtual_pyproject()
    }

    /// Map ripenv's verbosity/quiet settings to uv's `Printer` enum.
    pub fn uv_printer(&self) -> uv::printer::Printer {
        if self.quiet {
            uv::printer::Printer::Quiet
        } else if self.verbosity >= 1 {
            uv::printer::Printer::Verbose
        } else {
            uv::printer::Printer::Default
        }
    }

    /// Create a uv `Cache` with default settings.
    pub fn cache(&self) -> Result<Cache> {
        Cache::from_settings(false, None).context("failed to initialize uv cache")
    }

    /// Create a default `BaseClientBuilder`.
    pub fn client_builder(&self) -> BaseClientBuilder<'_> {
        BaseClientBuilder::default()
    }

    /// Create default `ResolverInstallerSettings`.
    pub fn resolver_installer_settings(&self) -> uv::settings::ResolverInstallerSettings {
        uv::settings::ResolverInstallerSettings::default()
    }

    /// Create default `ResolverSettings`.
    pub fn resolver_settings(&self) -> uv::settings::ResolverSettings {
        uv::settings::ResolverSettings::default()
    }

    /// Return the default `PythonInstallMirrors`.
    pub fn install_mirrors(&self) -> PythonInstallMirrors {
        PythonInstallMirrors::default()
    }

    /// Return the default `PythonPreference`.
    pub fn python_preference(&self) -> PythonPreference {
        PythonPreference::default()
    }

    /// Return the default `PythonDownloads`.
    pub fn python_downloads(&self) -> PythonDownloads {
        PythonDownloads::default()
    }

    /// Return the default `Concurrency`.
    pub fn concurrency(&self) -> Concurrency {
        Concurrency::default()
    }

    /// Return the default `Preview`.
    pub fn preview(&self) -> Preview {
        Preview::default()
    }
}

/// Check if a pyproject.toml exists and was NOT generated by ripenv.
///
/// Returns `true` if the file exists and does not contain the ripenv header.
pub fn has_user_pyproject(project_dir: &Path) -> bool {
    let path = project_dir.join("pyproject.toml");
    if !path.is_file() {
        return false;
    }
    match fs_err::read_to_string(&path) {
        Ok(content) => !content.starts_with("# Auto-generated by ripenv"),
        Err(_) => true, // Can't read it, assume it's user-owned
    }
}
