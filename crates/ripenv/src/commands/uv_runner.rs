//! Shared infrastructure for running uv subcommands.
//!
//! All ripenv commands that delegate to uv go through this module.
//! The [`UvRunner`] handles:
//!
//! 1. Discovering the Pipfile and project root
//! 2. Generating a virtual `pyproject.toml` from the Pipfile
//! 3. Running `uv` as a subprocess
//! 4. Propagating exit codes and output

use std::path::{Path, PathBuf};
use std::process::Command;

use anyhow::{Context, Result, bail};

use crate::pipfile::bridge::pipfile_to_pyproject_toml;
use crate::pipfile::discovery::{find_pipfile, project_name_from_dir};
use crate::pipfile::model::Pipfile;
use crate::printer::Printer;

/// Header written to the generated pyproject.toml so users know not to edit it.
const GENERATED_HEADER: &str = "\
# Auto-generated by ripenv from Pipfile. DO NOT EDIT.\n\
# This file is used internally by ripenv to delegate to uv.\n\
# Your source of truth is the Pipfile.\n\n";

/// Shared context for running uv commands.
///
/// Holds the parsed Pipfile, project paths, and printer configuration.
/// All command modules create a `UvContext` via [`UvContext::discover`],
/// then call methods like [`run_uv`] to execute uv subcommands.
pub struct UvContext {
    /// The parsed Pipfile.
    pub pipfile: Pipfile,
    /// Path to the Pipfile.
    pub pipfile_path: PathBuf,
    /// Project root directory (parent of Pipfile).
    pub project_dir: PathBuf,
    /// Path to the generated pyproject.toml.
    pub pyproject_path: PathBuf,
    /// Output printer.
    pub printer: Printer,
    /// Verbosity level (0 = normal, 1+ = verbose).
    pub verbosity: u8,
    /// Whether output is suppressed.
    pub quiet: bool,
}

impl UvContext {
    /// Discover the Pipfile and set up the context.
    ///
    /// Walks up from the current directory to find the Pipfile, parses it,
    /// generates the virtual pyproject.toml, and writes it to disk.
    pub fn discover(printer: Printer, verbosity: u8, quiet: bool) -> Result<Self> {
        let cwd = std::env::current_dir().context("failed to get current directory")?;
        let pipfile_path = find_pipfile(&cwd)?;
        let project_dir = pipfile_path
            .parent()
            .context("Pipfile has no parent directory")?
            .to_path_buf();
        let pyproject_path = project_dir.join("pyproject.toml");

        let pipfile = Pipfile::from_path(&pipfile_path).context("failed to parse Pipfile")?;

        let ctx = Self {
            pipfile,
            pipfile_path,
            project_dir,
            pyproject_path,
            printer,
            verbosity,
            quiet,
        };

        ctx.write_virtual_pyproject()?;

        Ok(ctx)
    }

    /// Write the virtual pyproject.toml to the project directory.
    pub fn write_virtual_pyproject(&self) -> Result<()> {
        let project_name = project_name_from_dir(&self.project_dir);
        let toml = pipfile_to_pyproject_toml(&self.pipfile, &project_name)?;
        let content = format!("{GENERATED_HEADER}{toml}");
        fs_err::write(&self.pyproject_path, content)
            .context("failed to write virtual pyproject.toml")?;
        self.printer.debug(&format!(
            "Wrote virtual pyproject.toml to {}",
            self.pyproject_path.display()
        ));
        Ok(())
    }

    /// Re-read the Pipfile and regenerate the virtual pyproject.toml.
    ///
    /// Call this after modifying the Pipfile (e.g., after `install` or `uninstall`).
    pub fn refresh(&mut self) -> Result<()> {
        self.pipfile =
            Pipfile::from_path(&self.pipfile_path).context("failed to re-parse Pipfile")?;
        self.write_virtual_pyproject()
    }

    /// Run a uv subcommand in the project directory.
    ///
    /// Returns the exit code from the uv process. Output is inherited
    /// (streamed to the user's terminal) unless `quiet` is set.
    pub fn run_uv(&self, args: &[&str]) -> Result<UvResult> {
        let uv = find_uv()?;

        self.printer
            .debug(&format!("Running: uv {}", args.join(" ")));

        let mut cmd = Command::new(&uv);
        cmd.args(args);
        cmd.current_dir(&self.project_dir);

        // Pass through verbosity
        if self.quiet {
            cmd.arg("--quiet");
        }
        for _ in 0..self.verbosity {
            cmd.arg("--verbose");
        }

        // Inherit stdio so user sees uv's output directly
        cmd.stdin(std::process::Stdio::inherit());
        cmd.stdout(std::process::Stdio::inherit());
        cmd.stderr(std::process::Stdio::inherit());

        let status = cmd
            .status()
            .with_context(|| format!("failed to run uv at '{}'", uv.display()))?;

        Ok(UvResult {
            exit_code: exit_code_as_u8(status.code()),
        })
    }

    /// Run a uv subcommand and capture its output (for programmatic use).
    pub fn run_uv_captured(&self, args: &[&str]) -> Result<CapturedUvResult> {
        let uv = find_uv()?;

        self.printer
            .debug(&format!("Running (captured): uv {}", args.join(" ")));

        let mut cmd = Command::new(&uv);
        cmd.args(args);
        cmd.current_dir(&self.project_dir);

        if self.quiet {
            cmd.arg("--quiet");
        }
        for _ in 0..self.verbosity {
            cmd.arg("--verbose");
        }

        let output = cmd
            .output()
            .with_context(|| format!("failed to run uv at '{}'", uv.display()))?;

        Ok(CapturedUvResult {
            exit_code: exit_code_as_u8(output.status.code()),
            stdout: String::from_utf8_lossy(&output.stdout).to_string(),
            stderr: String::from_utf8_lossy(&output.stderr).to_string(),
        })
    }
}

/// Result from a uv subprocess with inherited stdio.
pub struct UvResult {
    /// The exit code from the uv process.
    pub exit_code: u8,
}

impl UvResult {
    /// Whether the command succeeded (exit code 0).
    pub fn success(&self) -> bool {
        self.exit_code == 0
    }
}

/// Result from a uv subprocess with captured output.
pub struct CapturedUvResult {
    /// The exit code from the uv process.
    pub exit_code: u8,
    /// Captured stdout.
    pub stdout: String,
    /// Captured stderr.
    pub stderr: String,
}

impl CapturedUvResult {
    /// Whether the command succeeded (exit code 0).
    pub fn success(&self) -> bool {
        self.exit_code == 0
    }
}

/// Convert an optional process exit code to a `u8`.
///
/// Maps `None` (signal-killed) to 1 and clamps the `i32` to the `u8` range.
fn exit_code_as_u8(code: Option<i32>) -> u8 {
    match code {
        Some(c) => u8::try_from(c).unwrap_or(if c < 0 { 1 } else { 255 }),
        None => 1, // killed by signal
    }
}

/// Find the `uv` binary.
///
/// Search order:
/// 1. Same directory as the ripenv binary (co-located install)
/// 2. System PATH
fn find_uv() -> Result<PathBuf> {
    // Try co-located first (e.g., both in target/debug/)
    if let Ok(current_exe) = std::env::current_exe() {
        if let Some(dir) = current_exe.parent() {
            let uv_path = dir.join("uv");
            if uv_path.is_file() {
                return Ok(uv_path);
            }
            // Windows
            let uv_exe = dir.join("uv.exe");
            if uv_exe.is_file() {
                return Ok(uv_exe);
            }
        }
    }

    // Fall back to PATH
    which_uv_on_path()
}

/// Search for `uv` on the system PATH.
fn which_uv_on_path() -> Result<PathBuf> {
    let path_var = std::env::var_os("PATH").unwrap_or_default();
    for dir in std::env::split_paths(&path_var) {
        let candidate = dir.join("uv");
        if candidate.is_file() {
            return Ok(candidate);
        }
        let candidate_exe = dir.join("uv.exe");
        if candidate_exe.is_file() {
            return Ok(candidate_exe);
        }
    }
    bail!("Could not find 'uv' binary. Is uv installed?")
}

/// Check if a pyproject.toml exists and was NOT generated by ripenv.
///
/// Returns `true` if the file exists and does not contain the ripenv header.
pub fn has_user_pyproject(project_dir: &Path) -> bool {
    let path = project_dir.join("pyproject.toml");
    if !path.is_file() {
        return false;
    }
    match fs_err::read_to_string(&path) {
        Ok(content) => !content.starts_with("# Auto-generated by ripenv"),
        Err(_) => true, // Can't read it, assume it's user-owned
    }
}
